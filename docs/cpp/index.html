<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>liburlparser: liburlparser Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! --><!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">liburlparser Library </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2home_2runner_2work_2liburlparser_2liburlparser_2docs_2cpp_2mainpage"></a></p>
<div align="center" style="text-align: center; display: block; margin: 0 auto;"> <div style="max-width: 38rem; margin: 0 auto; display: block;"> <img src="https://github.com/MohammadRaziei/liburlparser/raw/master/docs/images/logo/liburlparser-logo-1.svg" alt="Logo" style="pointer-events: none;" class="inline"/></div></div><div align="center" style="text-align: center; display: block; margin: 0 auto;"><div style="max-width: 38rem; margin: 0 auto; display: block;"> <h3 align="center">Fastest domain extractor library for C++ </h3>
</div></div><div align="center" style="text-align: center; display: block; margin: 0 auto;"><div style="max-width: 38rem; margin: 0 auto; display: block;"> <h4 align="center">Complete library for parsing URLs with C++, Python and Command Line </h4>
</div></div><div align="center" style="text-align: center; display: block; margin: 0 auto;"><div style="max-width: 38rem; margin: 0 auto; display: block;"> </div> </div><h1><a class="anchor" id="autotoc_md1"></a>
Introduction</h1>
<p>liburlparser is a high-performance URL parsing library written in C++ with Python bindings. It provides efficient URL parsing and domain extraction capabilities while maintaining a consistent interface across both C++ and Python. This page introduces the core concepts, architecture, and features of liburlparser.</p>
<p>For installation instructions, see Installation. For usage examples, see Quick Start Guide.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Purpose and Scope</h1>
<p>The primary purpose of liburlparser is to parse URLs and extract their components with a focus on accurate domain extraction. The library is designed to:</p>
<ul>
<li>Parse URLs into their component parts (protocol, host, path, query parameters, etc.)</li>
<li>Extract domain information from hostnames, correctly handling public suffixes</li>
<li>Provide a consistent API across both C++ and Python</li>
<li>Offer superior performance compared to other URL parsing solutions</li>
</ul>
<h1><a class="anchor" id="autotoc_md3"></a>
Key Features</h1>
<ul>
<li><b>High Performance</b>: Optimized C++ implementation for fast URL parsing</li>
<li><b>Comprehensive URL Parsing</b>: Extract all components of a URL including protocol, domain, subdomain, suffix, path, query parameters, and fragments</li>
<li><b>Public Suffix List Support</b>: Accurate domain recognition using the public suffix list</li>
<li><b>Clean API Design</b>: Separate <code><a class="el" href="classTLD_1_1Url.html" title="Represents a URL.">TLD::Url</a></code> and <code><a class="el" href="classTLD_1_1Host.html" title="Represents a Host part of a URL.">TLD::Host</a></code> classes for better code organization</li>
<li><b>Cross-Platform Compatibility</b>: Works on Windows, Linux, and macOS</li>
<li><b>Automatic PSL Updates</b>: Updates the public suffix list automatically during build</li>
</ul>
<h1><a class="anchor" id="autotoc_md4"></a>
System Architecture</h1>
<p>liburlparser follows a layered architecture with C++ core components providing the parsing functionality and language bindings making this functionality available in Python.</p>
<div align="center" style="text-align: center; display: block; margin: 0 auto;"> <img src="https://raw.githubusercontent.com/MohammadRaziei/liburlparser/refs/heads/master/docs/cpp/images/interface-arch.svg" alt="Architecture Diagram" style="pointer-events: none; max-width: 38rem; margin: 0 auto; display: block;" width="100%" class="inline"/> </div><h1><a class="anchor" id="autotoc_md5"></a>
URL Parsing Process</h1>
<p>When parsing a URL, the library follows this general flow:</p>
<div class="image">
<object type="image/svg+xml" data="url-parsing-process.svg" style="pointer-events: none;"></object>
<div class="caption">
URL Parsing Process</div></div>
    <h1><a class="anchor" id="autotoc_md6"></a>
Core Components</h1>
<p>The library is built around two primary classes that work together to provide URL parsing functionality:</p>
<h2><a class="anchor" id="autotoc_md7"></a>
TLD::Url Class</h2>
<p>The <code><a class="el" href="classTLD_1_1Url.html" title="Represents a URL.">TLD::Url</a></code> class is responsible for parsing complete URLs and extracting all their components. It provides methods to access:</p>
<ul>
<li>Protocol (e.g., "https")</li>
<li>User information</li>
<li>Host (which is represented as a Host object)</li>
<li>Port</li>
<li>Path</li>
<li>Query parameters</li>
<li>Fragment</li>
</ul>
<h3><a class="anchor" id="autotoc_md8"></a>
Key Methods and Properties</h3>
<ul>
<li><code>protocol()</code>: Returns the protocol (e.g., "http", "https")</li>
<li><code>userinfo()</code>: Returns the user information part of the URL</li>
<li><code>host()</code>: Returns a <code><a class="el" href="classTLD_1_1Host.html" title="Represents a Host part of a URL.">TLD::Host</a></code> object representing the host part</li>
<li><code>port()</code>: Returns the port number</li>
<li><code>abspath()</code>: Returns the absolute path</li>
<li><code>query()</code>: Returns the query string</li>
<li><code>params()</code>: Returns the query parameters as a map</li>
<li><code>fragment()</code>: Returns the fragment (anchor)</li>
<li><code>str()</code>: Returns the complete URL as a string</li>
</ul>
<h2><a class="anchor" id="autotoc_md9"></a>
TLD::Host Class</h2>
<p>The <code><a class="el" href="classTLD_1_1Host.html" title="Represents a Host part of a URL.">TLD::Host</a></code> class focuses on parsing and extracting domain information from hostnames. It leverages the Public Suffix List (PSL) to correctly handle domain extraction, even for complex cases like "co.uk". It provides methods to access:</p>
<ul>
<li>Subdomain (e.g., "www" in "www.example.com")</li>
<li>Domain (e.g., "example" in "www.example.com")</li>
<li>Domain name (the combination of domain and suffix)</li>
<li>Suffix (e.g., "com" in "www.example.com" or "co.uk" in "example.co.uk")</li>
</ul>
<h3><a class="anchor" id="autotoc_md10"></a>
Key Methods and Properties</h3>
<ul>
<li><code>domain()</code>: Returns the domain part</li>
<li><code>subdomain()</code>: Returns the subdomain part</li>
<li><code>suffix()</code>: Returns the suffix (<a class="el" href="namespaceTLD.html">TLD</a>)</li>
<li><code>domainName()</code>: Returns the domain name (domain + suffix)</li>
<li><code>fulldomain()</code>: Returns the full domain (subdomain + domain + suffix)</li>
<li><code>str()</code>: Returns the host as a string</li>
<li><code>static fromUrl(const std::string&amp; url, bool ignore_www = false)</code>: Creates a Host object from a URL</li>
</ul>
<h1><a class="anchor" id="autotoc_md11"></a>
Usage Examples</h1>
<h2><a class="anchor" id="autotoc_md12"></a>
Basic URL Parsing</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="urlparser_8h.html">urlparser.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Parse a URL</span></div>
<div class="line">    <a class="code hl_class" href="classTLD_1_1Url.html">TLD::Url</a> url(<span class="stringliteral">&quot;https://www.example.com/path?param=value#section&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Access URL components</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Protocol: &quot;</span> &lt;&lt; url.protocol() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Domain: &quot;</span> &lt;&lt; url.domain() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Subdomain: &quot;</span> &lt;&lt; url.subdomain() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Suffix: &quot;</span> &lt;&lt; url.suffix() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Path: &quot;</span> &lt;&lt; url.abspath() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Query: &quot;</span> &lt;&lt; url.query() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Fragment: &quot;</span> &lt;&lt; url.fragment() &lt;&lt; std::endl;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassTLD_1_1Url_html"><div class="ttname"><a href="classTLD_1_1Url.html">TLD::Url</a></div><div class="ttdoc">Represents a URL.</div><div class="ttdef"><b>Definition</b> urlparser.h:67</div></div>
<div class="ttc" id="aurlparser_8h_html"><div class="ttname"><a href="urlparser_8h.html">urlparser.h</a></div><div class="ttdoc">Defines classes for parsing and handling URLs and hosts.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md13"></a>
Working with Hosts</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="urlparser_8h.html">urlparser.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Create a Host object directly</span></div>
<div class="line">    <a class="code hl_class" href="classTLD_1_1Host.html">TLD::Host</a> host1(<span class="stringliteral">&quot;www.example.com&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Create a Host object from a URL</span></div>
<div class="line">    <a class="code hl_class" href="classTLD_1_1Host.html">TLD::Host</a> host2 = <a class="code hl_function" href="classTLD_1_1Host.html#a093c6d2dc1fc783f991db28270eb0bb5">TLD::Host::fromUrl</a>(<span class="stringliteral">&quot;https://www.example.com/path?param=value&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Access Host components</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Domain: &quot;</span> &lt;&lt; host1.domain() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Subdomain: &quot;</span> &lt;&lt; host1.subdomain() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Suffix: &quot;</span> &lt;&lt; host1.suffix() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Domain Name: &quot;</span> &lt;&lt; host1.domainName() &lt;&lt; std::endl;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Compare hosts</span></div>
<div class="line">    <span class="keywordflow">if</span> (host1 == host2) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Hosts are equal&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassTLD_1_1Host_html"><div class="ttname"><a href="classTLD_1_1Host.html">TLD::Host</a></div><div class="ttdoc">Represents a Host part of a URL.</div><div class="ttdef"><b>Definition</b> urlparser.h:200</div></div>
<div class="ttc" id="aclassTLD_1_1Host_html_a093c6d2dc1fc783f991db28270eb0bb5"><div class="ttname"><a href="classTLD_1_1Host.html#a093c6d2dc1fc783f991db28270eb0bb5">TLD::Host::fromUrl</a></div><div class="ttdeci">static Host fromUrl(const std::string &amp;url, const bool ignore_www=DEFAULT_IGNORE_WWW)</div><div class="ttdoc">Create a Host object from a URL string.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14"></a>
Advanced Example</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="urlparser_8h.html">urlparser.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Parse a complex URL</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="classTLD_1_1Url.html">TLD::Url</a> url(</div>
<div class="line">        <span class="stringliteral">&quot;https://user:password@www.subdomain.example.co.uk:8080/path/to/resource?param1=value1&amp;param2=value2#section&quot;</span>,</div>
<div class="line">        <span class="keyword">true</span>  <span class="comment">// ignore_www parameter</span></div>
<div class="line">    );</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Access URL components</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Protocol: &quot;</span> &lt;&lt; url.protocol() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;User Info: &quot;</span> &lt;&lt; url.userinfo() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Domain: &quot;</span> &lt;&lt; url.domain() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Subdomain: &quot;</span> &lt;&lt; url.subdomain() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Suffix: &quot;</span> &lt;&lt; url.suffix() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Port: &quot;</span> &lt;&lt; url.port() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Path: &quot;</span> &lt;&lt; url.abspath() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Query: &quot;</span> &lt;&lt; url.query() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Fragment: &quot;</span> &lt;&lt; url.fragment() &lt;&lt; std::endl;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Access query parameters</span></div>
<div class="line">    <span class="keyword">auto</span> params = url.params();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; param : params) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Parameter: &quot;</span> &lt;&lt; param.first &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; param.second &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Get the host object</span></div>
<div class="line">    <a class="code hl_class" href="classTLD_1_1Host.html">TLD::Host</a> host = url.host();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Full Domain: &quot;</span> &lt;&lt; host.<a class="code hl_function" href="classTLD_1_1Host.html#acf1821768e5debcd0abb0c7bdb5afb5d">fulldomain</a>() &lt;&lt; std::endl;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassTLD_1_1Host_html_acf1821768e5debcd0abb0c7bdb5afb5d"><div class="ttname"><a href="classTLD_1_1Host.html#acf1821768e5debcd0abb0c7bdb5afb5d">TLD::Host::fulldomain</a></div><div class="ttdeci">const std::string &amp; fulldomain() const noexcept</div><div class="ttdoc">Get the full domain of the host.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md15"></a>
Public Suffix List</h1>
<p>The library uses the Public Suffix List (PSL) to accurately identify domain suffixes. The PSL is automatically downloaded during the build process, but you can also load it manually:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="urlparser_8h.html">urlparser.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Check if PSL is loaded</span></div>
<div class="line">    <span class="keywordtype">bool</span> pslLoaded = <a class="code hl_function" href="classTLD_1_1Host.html#aff7125526099471dc8afd3c552db5c83">TLD::Host::isPslLoaded</a>();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Load PSL from a file</span></div>
<div class="line">    <span class="keywordflow">if</span> (!pslLoaded) {</div>
<div class="line">        <a class="code hl_function" href="classTLD_1_1Host.html#a9d3ae56d7efea3d96b642326f2724cfa">TLD::Host::loadPslFromPath</a>(<span class="stringliteral">&quot;/path/to/public_suffix_list.dat&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Or load PSL from a string</span></div>
<div class="line">    std::string pslContent = <span class="stringliteral">&quot;...&quot;</span>; <span class="comment">// PSL content</span></div>
<div class="line">    <a class="code hl_function" href="classTLD_1_1Host.html#ab6d1c1bde77407fa4c5020db5c08ae86">TLD::Host::loadPslFromString</a>(pslContent);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassTLD_1_1Host_html_a9d3ae56d7efea3d96b642326f2724cfa"><div class="ttname"><a href="classTLD_1_1Host.html#a9d3ae56d7efea3d96b642326f2724cfa">TLD::Host::loadPslFromPath</a></div><div class="ttdeci">static void loadPslFromPath(const std::string &amp;filepath)</div><div class="ttdoc">Load the Public Suffix List from a file.</div></div>
<div class="ttc" id="aclassTLD_1_1Host_html_ab6d1c1bde77407fa4c5020db5c08ae86"><div class="ttname"><a href="classTLD_1_1Host.html#ab6d1c1bde77407fa4c5020db5c08ae86">TLD::Host::loadPslFromString</a></div><div class="ttdeci">static void loadPslFromString(const std::string &amp;filestr)</div><div class="ttdoc">Load the Public Suffix List from a string.</div></div>
<div class="ttc" id="aclassTLD_1_1Host_html_aff7125526099471dc8afd3c552db5c83"><div class="ttname"><a href="classTLD_1_1Host.html#aff7125526099471dc8afd3c552db5c83">TLD::Host::isPslLoaded</a></div><div class="ttdeci">static bool isPslLoaded() noexcept</div><div class="ttdoc">Check if the Public Suffix List (PSL) is loaded.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md16"></a>
Building and Installation</h1>
<h2><a class="anchor" id="autotoc_md17"></a>
Prerequisites</h2>
<ul>
<li>C++17 compatible compiler</li>
<li>CMake 3.19 or higher</li>
</ul>
<h2><a class="anchor" id="autotoc_md18"></a>
Build Steps</h2>
<div class="fragment"><div class="line">git clone https://github.com/mohammadraziei/liburlparser</div>
<div class="line">mkdir -p build &amp;&amp; cd build</div>
<div class="line">cmake ..</div>
<div class="line">make</div>
<div class="line">sudo make install</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md19"></a>
Running Tests</h2>
<div class="fragment"><div class="line">make test</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md20"></a>
Generating Documentation</h2>
<div class="fragment"><div class="line">make docs</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md21"></a>
Performance Comparison</h1>
<p>URL Parser is designed for high performance. In benchmarks, it consistently outperforms other URL parsing libraries:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Library   </th><th class="markdownTableHeadNone">Function   </th><th class="markdownTableHeadNone">Time (Extract from Host)   </th><th class="markdownTableHeadNone">Time (Extract from URL)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">liburlparser   </td><td class="markdownTableBodyNone">Host   </td><td class="markdownTableBodyNone">1.12s   </td><td class="markdownTableBodyNone">2.10s    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Other libraries   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone">1.50s - 34.48s   </td><td class="markdownTableBodyNone">2.24s - 57.87s   </td></tr>
</table>
<p><em>Tests were run on a file containing 10 million random domains and 1 million random URLs.</em></p>
<h1><a class="anchor" id="autotoc_md22"></a>
License</h1>
<p>This library is distributed under the MIT License. See the LICENSE file for more information. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun May 4 2025 19:25:57 for liburlparser by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
